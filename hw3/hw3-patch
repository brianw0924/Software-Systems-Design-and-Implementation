diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 1fc8faa6e973..4e7def488676 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -850,9 +850,11 @@ __SYSCALL(__NR_pidfd_open, sys_pidfd_open)
 #define __NR_clone3 435
 __SYSCALL(__NR_clone3, sys_clone3)
 #endif
+#define __NR_expose_pte 436
+__SYSCALL(__NR_expose_pte, sys_expose_pte)
 
 #undef __NR_syscalls
-#define __NR_syscalls 436
+#define __NR_syscalls 437
 
 /*
  * 32 bit systems traditionally used different
diff --git a/kernel/sys.c b/kernel/sys.c
index a611d1d58c7d..89d0ae3b18d4 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -4,7 +4,7 @@
  *
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
-
+#include <linux/expose_pte.h>
 #include <linux/export.h>
 #include <linux/mm.h>
 #include <linux/utsname.h>
@@ -2584,6 +2584,55 @@ SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
 	return 0;
 }
 
+SYSCALL_DEFINE1(expose_pte, struct expose_pte_args __user *, args)
+{
+
+	// int remap_pfn_range (
+	//	struct vm_area_struct * vma,
+	// 	unsigned long addr,
+	// 	unsigned long pfn,
+	// 	unsigned long size,
+	// 	pgprot_t prot
+	// );
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+	int ret;
+	unsigned long page_count = (args->end_vaddr - args->begin_vaddr) >> 12;
+	unsigned long i = 0;
+	struct task_struct *task = get_pid_task(find_get_pid(args->pid), PIDTYPE_PID);
+	struct mm_struct *mm = get_task_mm(task);
+	struct vm_area_struct *vma;
+	down_read(&mm->mmap_sem);
+	vma = mm->mmap;	
+	for(; i < page_count; i++, vma = vma->vm_next) {
+		pr_info("va: %lx\n", args->begin_vaddr);
+		// walk through page table, find the pte physical addr
+		pgd = pgd_offset(mm, vma->vm_start);
+		pud = pud_offset(pgd, vma->vm_start);
+		pmd = pmd_offset(pud, vma->vm_start);
+		pte = pte_offset_map(pmd, vma->vm_start);
+		pr_info("pmd_page_paddr (should be PTE paddr): %llx\n\n", pmd_page_paddr(READ_ONCE(*(pmd))));
+		pr_info("addr=%lx\npfn=%lx\nsize=%lx\n\n",
+			(unsigned long)(args->begin_pte_vaddr + i * 4096),
+			(unsigned long)pmd_page_paddr(READ_ONCE(*(pmd))),
+			(unsigned long)4096);
+		// remap target PTE table to mine
+		ret = remap_pfn_range(
+			vma,
+			(unsigned long)(args->begin_pte_vaddr + i * 4096),
+			(unsigned long)pmd_page_paddr(READ_ONCE(*(pmd))),
+			(unsigned long)4096,
+			vma->vm_page_prot
+			);
+		pr_info("return: %d\n", ret);
+	}
+	up_read(&mm->mmap_sem);
+
+	return 0;
+}
+
 #ifdef CONFIG_COMPAT
 struct compat_sysinfo {
 	s32 uptime;
